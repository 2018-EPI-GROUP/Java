class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
         ListNode cur1 = l1, cur2 = l2;

        int flag = 0;   //flag表进位

        while (true) {      // l2节点加到l1上

            cur1.val += cur2.val + flag;

            if (cur1.val >= 10) {

                cur1.val -= 10;

                flag = 1;

            } else {

                flag = 0;

            }

            if (cur1.next == null || cur2.next == null) {

                break;

            }

            cur1 = cur1.next;         //向下加

            cur2 = cur2.next;

        }

        if (cur1.next == null && cur2.next == null && flag == 1) {    //如果链表l1和链表l2均遍历结束，且有进位，则在链表l1末尾添加1

            cur1.next = new ListNode(flag);

        } else if (cur1.next == null && cur2.next != null) { 
        //如果链表l1遍历结束，但是链表l2还没有遍历结束，把链表l2剩余部分添加到链表l1末尾，注意进位flag的影响

            cur1.next = cur2.next;

            cur1.next.val = flag + cur2.next.val;

            ListNode cur = cur1.next;

            while (cur.val >= 10) {

                cur.val -= 10;

                if (cur.next == null) {

                    cur.next = new ListNode(1);

                } else {

                    cur.next.val += 1;

                    cur = cur.next;

                }

            }

        } else if (cur1.next != null) {   //如果链表l2遍历结束，但是链表l1还没有遍历结束，就把链表l1剩余部分添加到链表2末尾，注意进位flag的影响

            cur1.next.val += flag;

            ListNode cur = cur1.next;

            while (cur.val >= 10) {

                cur.val -= 10;

                if (cur.next == null) {

                    cur.next = new ListNode(1);

                } else {

                    cur.next.val += 1;

                    cur = cur.next;

                }

            }

        }

        return l1;

    }

}




时间复杂度尽可能低的两单链表连接

 LinkList Link(LinkList l1, LinkList l2,int m,int n)  //先取较短链表的头结点，再找到短链表的结尾结点，最后将另一个表的开始结点链接到前表的结尾结点
        {
            ListNode *p;   //p指向短表的末结点
            ListNode *q;   //q指向长表的开始结点
            ListNode *s;   //s指向短表的头结点
            if(m<n){
                s=L1;q=L2->next;free(L2);          //l1为短表，l2为长表 释放空结点
            }
            else {
                s=L2;q=L1->next;free(L1);          //l2为短表，l1为长表 释放空结点
            }
                p=s;
            while(p->next)                         //找出短表的结尾结点
            {
                p=p->next;
            }p->next=q;                             //把长表的头结点链接到短表的最后一个结点后
            retuen s;
        }
    }
