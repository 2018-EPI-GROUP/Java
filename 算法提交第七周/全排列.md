## 全排列

- **问题描述**

给定一个没有重复数字的序列，返回其所有可能的全排列。

示例:

输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

- **解决方法：回溯法**

  回溯法：回溯法，就是试探法，按照优选条件去向前搜索，以达到目标。

  但是在搜索到某一步时，发现原先这样并不能满足条件，就回退一步重新选择，这种走不通就退回再走的技术成为回溯法。

- **解决代码**

```java
class Solution {
   public List<List<Integer>> permute(int[] nums) {
	        List<List<Integer>> list = new ArrayList<List<Integer>>();
	        int a[] = new int[nums.length];
			int book[] = new int[nums.length];
			Arrays.fill(a, 0);
			Arrays.fill(book, 0);
	        dfs(0,a,book,nums,nums.length,list);
	        return list;
	    }
	 public void dfs(int step,int a[],int book[],int []nums,int n,List<List<Integer>> queue) {
			//如果所有位置都放置完，则返回
			if(step==n) {
				List list =new ArrayList<>();
				for(int i=0;i<n;i++) {
					list.add(a[i]);
				}
				queue.add(list);
				return ;
			}
			for(int i=0;i<n;i++) {
				//如果此牌未被放置
				if(book[i]==0) {
					//对现在的位置放置数字
					a[step]=nums[i];
					//标记已经放过
					book[i]=1;
					//递归放置下一个位置
					dfs(step+1,a,book,nums,n,queue);
					//将刚才放号的数字收回，以让其他位置也能放置该数字
					book[i]=0;	
				}	
			}
		}
}
```

