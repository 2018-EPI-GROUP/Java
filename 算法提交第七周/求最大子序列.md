## 求最大子序列

- **问题描述**

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

```java
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6
```

- **解题方法**

  - **贪心算法**

  ```java
   public int maxSubArray(int[] nums) {
          if(nums.length==1) return nums[0];
  	       int i,j;
  	       int Max=0,sea=0,MAX2=-99999999,sea2=0;
  	       for(i=0;i<nums.length;i++){
  	           Max=nums[i];
  	           sea=nums[i];
  	           for(j=i+1;j<nums.length;j++){
  	               sea+=nums[j];
  	               if(sea>Max){
  	                   Max=sea;
  	               }
  	           }
  	           sea2=Max;
  	           if(sea2>MAX2) MAX2=sea2;
  	       }
  	       return MAX2;
         }
  ```

  - **分治算法**

  ```java
  public int maxSubArray(int[] nums) {
      int left=0,right=nums.length-1;
      return divide(nums,left,right);
  }
  public int divide(int []nums,int left,int right){
      if(nums.length==1) return nums[0];
      int MaxLeft,Maxright;
      int MAXBorderLeft,MAXBorderRight;
      int BorderLeft,BorderRight;
      if(left==right){
          return nums[left];					//如果只剩一个元素，直接返回
      }
      int mid = (left+right)/2;
      MaxLeft = divide(nums,left,mid);		//递归求解左边的最大子序列
      Maxright = divide(nums,mid+1,right);	//递归求解右边的最大子序列
      MAXBorderLeft=-99999; BorderLeft=0; 
      //左边包含边界的最大和
      for(int i=mid;i>=left;i--){
          BorderLeft +=nums[i];
          if(MAXBorderLeft<BorderLeft){
              MAXBorderLeft = BorderLeft;
          }
      }
      //右边包含边界的最大和
      MAXBorderRight=-999999; BorderRight=0;
      for(int i=mid+1;i<=right;i++){
          BorderRight +=nums[i];
          if(MAXBorderRight<BorderRight){
              MAXBorderRight = BorderRight;
          }
      }
      int  Max1,Max3;
      Max1 = Math.max(MaxLeft, Maxright);
      Max3 = Math.max(Max1,MAXBorderLeft+MAXBorderRight);
      return Max3;		//从倒数第二层依次向上返回，最大值
  }
  ```

  