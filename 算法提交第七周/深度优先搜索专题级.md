# 深度优先搜索专题级

## 一、深度优先搜索

	### 1、基本概念

​	深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。**这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止**。属于盲目搜索。

### 2、特点

​	==每一步的解决方法都一样==

## 二、搜索(穷举)

### 1、概念

​		搜索就是用问题的所有可能去试探，按照一定的顺序、规则，不断去试探，直到找到问题的解，试完了也没有找到解，那就是无解，试探时一定要试探完所有的情况（实际上就是穷举）

- 初始状态：对于问题的第一个状态。
- 目标状态：要求的状态叫目标状态。

- 扩展：产生新的状态的过程（由一个状态，应用规则，产生新状态的过程)。
- 搜索就是把规则应用于实始状态，==在其产生的状态中，直到得到一个目标状态为止==。

### 2、算法

- **深度优先搜索**

  - 基本框架

    ```c
    void dfs(int step){
    	判断边界
        尝试每种可能for(i=0;i<n;i++){
            继续尝试下一步dfs(step+1);
        }
        返回
    }
    ```

  - 在深度优先搜索过程中，常利用***递归算法***，因为递归时可以自动实现回溯（利用[局部变量](https://baike.baidu.com/item/局部变量)）所以使用递归编写深度优先搜索程序相对简单。

- **穷举**

## 三、例题

### 1、全排列

- **基本思路**：

  1. 将全排列问题抽象成数字的放置问题。
  2. 对每个位置依次放置数字，当一个放好后，紧接着放下一个。
  3. 在放置数字时，首先判断此数字是否已经被其他位置占据，如果没有再放置。
  4. 一直重复上述动作，直到所有的位置都被放置。
  5. 若放的不能再放，则返回到上一个位置接着放另一个数字。

- **解决算法**

  1. DFS
  2. 递归算法

- **代码描述**

  ```java
  public static void dfs(int step,int a[],int book[],int n) {
      //如果所有位置都放置完，则返回
      if(step==n+1) {
          for(int i=1;i<=n;i++) {
              System.out.print(a[i]);
          }
          System.out.println();
          return ;
      }
      for(int i=1;i<=n;i++) {
          //如果此牌未被放置
          if(book[i]==0) {
              //对现在的位置放置数字
              a[step]=i;
              //标记已经放过
              book[i]=1;
              //递归放置下一个位置
              dfs(step+1,a,book,n);
              //将刚才放号的数字收回，以让其他位置也能放置该数字
              book[i]=0;	
          }	
      }
  }
  ```

  

