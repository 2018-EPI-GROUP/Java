##   静态链表的操作

```c
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#define MAX 10
typedef struct
{
	int num;
	int next;
}List;
List list[MAX];
int SL=1, VL=0,ML;
void init(void) {
	int i=0,t;
	do {
		list[i].next = i + 1;
		i++;
	} while (i<MAX-1);
	/*printf("请输入第一个节点数据!");
	scanf("%d", &list[SL].num);
	list[SL].next = -1;*/
	ML = SL;
	list[MAX - 1].next = -1;
}
int malloc() {
	int t;
	if (list[VL].next != -1) {			//如果VL还有可用空间
		t = list[VL].next;				//获取备用链表的节点
		list[VL].next = list[t].next;	//再更新备用链表的头节点位置
	}	
	return t;
}
void free(int t) {
	list[t].next = list[VL].next;		//先进行连接
	list[VL].next = t;					//再更新备用链表的头节点位置
}
int insert() {
	if (list[VL].next == -1) {
		printf("可用空间已满!无法录入!\n");
		return 0;
	}
	else{
		int node = malloc();
		list[ML].next = node;
		printf("Please enter your node:");
		scanf("  %d", &list[node].num);
		list[node].next = -1;
		ML = node;
	}
	return 1;
}
int find(int num) {
	int i = SL;
	while (list[i].next != -1 && list[i].num != num) {
		i = list[i].next;
	}
	if (list[i].num == num) {
		printf("已经找到,该数字的位置为%d\n",i);
		return i;
	}
	else {
		printf("没有找到!\n");
		return 0;
	}
}
int delete(int num) {
	int i=SL;
	while (list[i].next != -1 &&list[list[i].next].num != num) {
		i = list[i].next;
	}
	if (list[list[i].next].num == num) {
		int p = list[i].next;
		list[i].next = list[list[i].next].next;
		free(p);
		printf("删除成功!\n");
		return 1;
	}
	else {
		printf("此静态链表中无该数!\n");
		return 0;
	}
}
int change(int num) {
	int p = find(num);
	if (p != 0) {
		printf("请输入更改后的值:");
		int ms;
		scanf("%d", &ms);
		list[p].num = ms;
		return 1;
	}
	else {
		printf("此静态链表中无该数!\n");
		return 0;
	}
}
int main() 
{
	init(list);
	int dat,i=0;
	init();
	while (insert());
	printf("num\tvernier\n");
	while (i<MAX) {
		printf("%d\t%d\n", list[i].num,list[i].next);
		i++;
	}
	find(4);
	//delete(4);
	//delete(6);
	//delete(7);
	i = 0;
	printf("请输入你想更改的值:");
	int num;
	scanf("%d", &num);
	change(num);
	while (i < MAX) {
		printf("%d\t%d\n", list[i].num, list[i].next);
		i++;
	}
}

```

