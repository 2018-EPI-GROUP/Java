### 搜索旋转排序数组

##### 问题描述

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 *O*(log *n*) 级别。

**示例 1:**

```
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
```

**示例 2:**

```java
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

#### 解题思路

由于旋转后有明显的分界点，所以可以计算出此时分界点的索引，进而确定左右各自的数量，然后利用排序，二分法查找，找到排序后的索引，再根据分析出来的位置关系得出结果。

#### 代码

```java
public int search(int[] nums, int target) {
          if(nums.length==0) return -1;
        int i = 0,count_r = 0,count_l=0,recode=-1;
        for(i=0;i<nums.length;i++){
            if(i+1<nums.length&&nums[i]>nums[i+1]){
                count_r=i+1;
                break;
            }
        }
        count_l=nums.length-count_r;
        Arrays.sort(nums);
        int left=0,right=nums.length-1;
        while(left<=right){ 
            int mid = left + (right-left)/2;
            if(nums[mid]<target)  left=mid+1;
            else if(nums[mid]>target) right=mid-1;
            else{
                recode=mid;
                break;
            }
        }
        if(0<=recode&&recode<count_l) recode+=count_r;
        else if(recode>=count_l) recode-=count_l;
        return recode;
        
        
    }
```

