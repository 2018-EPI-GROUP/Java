## 寻找峰值

峰值元素是指其值大于左右相邻值的元素。

给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。

数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞。

```
示例 1:
输入: nums = [1,2,3,1]
输出: 2
解释: 3 是峰值元素，你的函数应该返回其索引 2。
示例 2:

输入: nums = [1,2,1,3,5,6,4]
输出: 1 或 5 
解释: 你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
```

#### 解题思路

**方法一：二分查找**

1.当全为降序时，由于nums[-1]为-∞,所以最左边为峰值；

2.当全为升序时，由于nums[i+1]为-∞，所以最右边为峰值；

3.当中间有峰值时，根据上述情况，

如果nums[mid]<nums[mid+1]此时为部分升序，所以其右边必定存在峰值，此时抛弃左边部分,left=mid+1;

如果nums[mid]>nums[mid+1]此时为部分降序，所以其左边必定存在峰值，此时抛弃右边部分,right=mid;

**代码**

```java
public int findPeakElement(int[] nums) {
    int left=0,right=nums.length-1;
    while(left<right) {
        int mid = left+(right-left)/2;
        if(nums[mid]<nums[mid+1]) {
            left=mid+1;
        }else {
            right=mid;
        }
    }
    return left;
}
```

**方法二：暴力解法**

**代码**

```java
 public int findPeakElement(int[] nums) {
     int flag=1;
     if(nums.length==1) return 0;		//只有一个元素，直接返回0
     flag=(nums[0]>nums[1])?1:0;		//判断开头是否为降序
     for(int i=1;i<nums.length-1;i++) {		//寻找峰值
         if(nums[i]>nums[i+1]&&nums[i-1]<nums[i]) {
             return i;
         }	
         if(nums[i]<nums[i+1]) {		//如果中间有升序，更改flag
             flag=0;
         }
     }
     //若中间无峰值，且为升序，则最后一个元素为峰值，若为降序的话，第一个元素为峰值。
     return (flag==0)?nums.length-1:0;
 }
```

