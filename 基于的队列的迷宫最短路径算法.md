## 基于的队列的迷宫最短路径算法

--------------

```c
#include<stdio.h>
#define m 6
#define n 8
typedef struct			//每一步所能到达的点 
{
	int x,y;
	int pre;
}sp;
typedef struct				//八个方向
{
	int x,y;
}item;
item move[8]; 
	int front,rear;
void creatItem(void)
{
	move[0].x=0;
	move[0].y=1;
	move[1].x=1;
	move[1].y=1;
	move[2].x=1;
	move[2].y=0;
	move[3].x=1;
	move[3].y=-1;
	move[4].x=0;
	move[4].y=-1;
	move[5].x=-1;
	move[5].y=-1;
	move[6].x=-1;
	move[6].y=0;
	move[7].x=-1;
	move[7].y=1;
}
void restore(int maze[m+2][n+2])
{
	int i,j;
	for(i=0;i<m+2;i++)
	{
		for(j=0;j<n+2;j++)
		{
			if(maze[i][j]==-1)
				maze[i][j]+=1;
		}
	}
}
void printMaze(int maze[m+2][n+2])
{
	int i,j;
	for(i=0;i<m+2;i++)
	{
		for(j=0;j<n+2;j++)
		{
			printf("%3d",maze[i][j]);
		}
		printf("\n"); 
	}
}
int search(int maze[m+2][n+2],sp peat[20])
{
	int i,j,k,x,y;
	front=rear=0;
	{
		peat[0].x=1;
		peat[0].y=1;
		peat[0].pre=-1;	
	}//入口点入队 
	maze[1][1]=-1;
	while(front<=rear)
	{
		x=peat[front].x;
		y=peat[front].y;
		for(k=0;k<8;k++) 
		{
			i=x+move[k].x;
			j=y+move[k].y;
			if(maze[i][j]==0)
			{
				rear++;
				peat[rear].x=i;
				peat[rear].y=j;
				peat[rear].pre=front;			//记下该点的前驱点的坐标对应的下标
				maze[i][j]=-1;	
			}
			if(i==m&&j==n)
				return 1;
		}
		front++;
	
	}
	return 0;
 } 
 void printPath(sp *peat)
 {
 	int i;
 	i=rear;
 	do
 	{
 		printf("(%d,%d)<-",peat[i].x,peat[i].y,peat[i]);
 		i=peat[i].pre;
	}while(i!=0);
	printf("(%d,%d)",peat[0].x,peat[0].y);
	 putchar('\n');
 }
main()
{
	int i,j;
	sp peat[50];
	int maze[m+2][n+2]={
	{1,1,1,1,1,1,1,1,1,1},
	{1,0,1,1,1,0,1,1,1,1},
	{1,1,0,1,0,1,1,1,1,1},
	{1,0,1,0,0,1,1,1,1,1},
	{1,0,1,1,1,0,0,1,1,1},
	{1,1,0,0,1,1,0,0,0,1},
	{1,0,1,1,0,0,1,1,0,1},
	{1,1,1,1,1,1,1,1,1,1}};
	creatItem();
	int count=0;
	if(search(maze,peat)==1)
	{
		restore(maze);
	    printMaze(maze);
		printPath(peat);
	}
	else
		printf("没有找到路径！");
 } 
```

​		1.计算迷宫路径时为保证统一可先用1表示的==外围墙==将迷宫包围起来，以便于实现。

​		