## 插入排序一组

#### 直接插入排序

- 特点**：

  1.时间复杂度：O(n^2);

  2.稳定排序。

  3.每次从有序列中，查找当前无序列的插入位置，==从后往前查==

- **代码**

```c
void insertSort(int num[]) {
	int i, j;
	for (i = 2; i <= MAX; i++) {		//第一个看作已被排序好
		if (num[i - 1] > num[i])		//如果当前数字小于之前的数字，则进入排序
		{
			num[0] = num[i];			//将0号元素看成哨兵，则接纳此次要插入的元素
			for (j = i - 1; j > 0 && num[0] < num[j]; j--)	//从当前元素的前一个元素开始，依次查找，直到找到比它小的元素
				num[j + 1] = num[j];		//如果有比他大的元素，则将之前的元素向后腾一位
			num[j+1] = num[0];		//最后找到比它小的值，查到此元素的后面
		}
	}
}
```

#### 折半插入排序

- 特点

  1.利用二分法查找插入的位置；

  2.时间复杂度:O(n^2)

  3.稳定排序;

  4.此排序是直接排序的进化版，在数多的时候，就更能体现出它的优势所在(二分查找)。

- **基本思路**

  在之前已经确定的有序表中确定插入的位置，不断用二分有序表来确定插入位置，即通过待插入记录和有序表剧中的值比较，然后将有序表一分为二，下次比较在其中一个有序表中进行，有一分为二，如此往复，直到low>high退出循环。



- **代码演示**

```java
public void InsertSort(int num[]) {
	int i, j;
	int mid, high, low;
	for (i = 2; i <=num.length-1; i++) {	//假设第一个元素已经排好序
		if (num[i - 1] > num[i]) {	//如果当前数字小于之前的数字，则进入排序
			num[0] = num[i];	//将0号元素看成哨兵，则接纳此次要插入的元素
			high = i - 1;		//高位为i-1
			low = 1;			//低位为1
			while (low <= high) {	//利用二分法查找要插入的位置，知道low>high
				mid = (low + high) / 2;
				if (num[mid] < num[0])
					low = mid + 1;
				else
					high = mid - 1;
			}
			for (j = i - 1; j >= high + 1; j--)	//此时mid为要插入的位置
				num[j + 1] = num[j];	//往后移，留出插入位置
			num[j + 1] = num[0];	//将元素插入
		}
	}
}
```

#### Shell排序（直接插入排序的改进）

- **基本思想**

  1.直接插入排序算法简单，在n值较小时，效率较高；

  2.在n值很大时，==若序列基本有序==，效率依然较高

  ![Shell](D:\study\p\Shell.gif)

希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。

![Shell](D:\study\p\Shell.png)

```c
void ShellInsert(int num[],int dk)
{
	int i, j;
	for (i = 2; i <= MAX; i++) {		//第一个看作已被排序好
		if (num[i - dk] > num[i])		//如果子序列中当前数字小于之前的数字，则进入排序
		{
			num[0] = num[i];			//将0号元素看成哨兵，则接纳此次要插入的元素
			for (j = i - dk; j > 0 && num[0] < num[j]; j-=dk)	//从当前元素的前一个元素开始，依次查找，直到找到比它小的元素
				num[j + dk] = num[j];		//如果有比他大的元素，则将之前的元素向后腾一位
			num[j + dk] = num[0];		//最后找到比它小的值，查到此元素的后面
		}
	}
}
void ShellSort(int num[]) {
	int i;
	int add[4] = { 5,3,2,1 };		//设置增量数组，注意增量数组的最后一个元素必须为1
	for (i = 0; i < 4; i++) {
		ShellInsert(num, add[i]);		//依次降低增量
	}
}
```

