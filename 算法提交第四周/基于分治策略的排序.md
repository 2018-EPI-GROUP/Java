## 基于分治策略的排序

#### 快速排序

![1575507906454](C:\Users\gaidi\AppData\Roaming\Typora\typora-user-images\1575507906454.png)

1.设置基准数pivot key和双指针low和high；

2.通过一趟排序将待排序记录分割成独立的两部分（基准值的左边部分和右边部分），其中一部分的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，已达到整个序列有序的目的

3.**注意:每次查找时，先让high走**(首先要找到比较小的值)

-------------------------------------

```c
int partition(int num[], int low, int high) {
	num[0] = num[low];			//将每个子队列的首元素，储存在0号元素中
	int i, j, pro;
	pro = num[low];		//记录支点的值
	while (low < high) {	//从表的两端向中间扫描
		while (low < high && pro < num[high])	high--;	//从右往左找比支点小的值
		num[low] = num[high];		//如果找到，则将其补到low位上(小的放右边)
		while (low<high && pro>num[low]) low++;	//从左往右找壁纸点大的值
		num[high] = num[low];		//如果找到，则将其补到high位上(大的放左边)
	}
	num[low] = num[0];		//此时low处为支点的最佳位置(左边都比他小，右边都比他大)
	return low;		//返回支点所处的位置
}
void QSort(int num[],int low,int high ) {	//利用递归的思想快速排序
	if (low < high) {
		int mid;
		mid = partition(num, low, high);	//将表一分为二，并返回它的支点位置
		QSort(num, low, mid - 1);	//对其左子序列进行同样的划分
		QSort(num, mid + 1, high);	//对其右子序列进行同样的划分
	}
}
```

#### 归并排序

![img](https://upload-images.jianshu.io/upload_images/7789414-b410a7c0fea50eba.png?imageMogr2/auto-orient/strip|imageView2/2/w/1141/format/webp)

![img](https://upload-images.jianshu.io/upload_images/7789414-4b8f4cb3cb5f0a9f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

