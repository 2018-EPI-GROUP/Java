## 哈夫曼树的构建

```c
#include<stdio.h>
#define MAX 30
#define MAXNode Max*2-1;
typedef struct {
	int weight;				//节点的权值
	int parent;				//节点的父节点序号
    int lchild;				//节点的左孩子序号
    int rchild;				//节点的右孩子序号
}Huff, * Hman;
Huff H[MAX];				//声明全局Huff数组变量
void creatHuff(int n)		//创建哈夫曼树
{
	int i, j, m1, m2, x1, x2;
	H[0].lchild = H[0].rchild = H[0].parent = H[0].weight = -3;	//将第一个元素置空，不用，以增强代码的易读性
	for (i = 1; i <= 2 * n - 1; i++)	//将所有的节点进行初始化
	{
		H[i].lchild = -1;
		H[i].parent = -1;
		H[i].rchild = -1;
		H[i].weight = 0;
	}
	for (i = 1; i <= n; i++) {	//循环输入每个节点的权值
		scanf_s("%d", &H[i].weight);
	}
	for (i = 1; i < n; i++) {	//总共结合n-1次
		m1 = 1000;	//m1表示的是最小元素的小标
		m2 = 1000;	//m2表示的是次小元素的下标
		x1 = x2 = 0;
		for (j = 1; j < n + i; j++) {
			//如果当前元素比最小的元素小则更新最小的和次小的元素
			if (H[j].weight < m1 && H[j].parent == -1) {
				m2 = m1; x2 = x1;
				m1 = H[j].weight;
				x1 = j;
			}
			//如果当前元素只比次小的元素小，则更新次小的元素，最小的元素不变
			else if (H[j].weight < m2 && H[j].parent == -1) {
				m2 = H[j].weight;
				x2 = j;
			}
		}
        /*将找出的两棵子树合并为一棵子树*/
		H[x1].parent = n + i;	
		H[x2].parent = n + i;
		H[n + i].lchild = x1;
		H[n + i].rchild = x2;
		H[n + i].weight = H[x1].weight + H[x2].weight;	
	}
}
void print(int i) {	//先序递归遍历
	if (i <= 0) return;
	printf("%d  ", H[i].weight);
	find(H[i].lchild);
	find(H[i].rchild);
}
void find(int n) {	//找出根节点所在元素的下标
	int i, j = 1;
	while (H[j].parent != -1) j++;
	find(j);
}
int main() {
	int n;
	printf("请输入你的节点:");
	scanf_s("%d", &n);
	creatHuff(n);
	int i;
	print(n);
	printf("\n%d", sum);
}
```

