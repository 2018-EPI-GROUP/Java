## 二叉树基本操作

**实验内容及要求**

编程实现含有n个结点的二叉树的建立和先序遍历。

1. 编程实现含有n个结点的二叉树，要求根据图1，程序可手动输入结点数目，输出结果；

2.编程实现对图1二叉树的先序遍历，用递归和非递归两种方法实现； 

 

![img](file:///C:\Users\gaidi\AppData\Local\Temp\msohtmlclip1\01\clip_image002.jpg)

- **代码分析**

  - **头文件**

  ```c
  #ifndef TREE_H_
  #define TREE_H_
  #include<stdio.h>
  #define MAX 20
  typedef struct stu {
  	int data;
  	struct stu* lchild, * rchild;
  }TNode, * Ttree;
  void creat(Ttree* T) {
  	Ttree p;
  	p = *T;
  	p->lchild = NULL;
  	p->rchild = NULL;
  	printf("请输入代码:");
  	scanf_s("%d", &p->data);
  }
  int insertLdhild(Ttree T, int x) {
  	Ttree p, q;
  	p = T;
  	if (p == NULL) return -1;
  	q = (Ttree)malloc(sizeof(TNode));
  	if (q == NULL) {
  		printf("获取错误!");
  	}
  	else {
  		p->lchild = q;
  		q->data = x;
  		q->lchild = q->rchild = NULL;
  		return 1;
  	}
  }
  int insertRchild(Ttree T, int y) {
  	Ttree p, q;
  	p = T;
  	if (p == NULL) return -1;
  	q = (Ttree)malloc(sizeof(TNode));
  	if (q == NULL) {
  		printf("获取错误!");
  	}
  	else {
  		q->data = y;
  		p->rchild = q;
  		q->lchild = q->rchild = NULL;
  		return 1;
  	}
  }
  /*void print(Ttree T) {
  	Ttree p, q;
  	Ttree Node[MAX];
  	int top = 0;
  	p = T;
  	if (p == NULL) return;
  	while (!(p == NULL && top == 0)) {
  		while (p) {
  			printf("%d  ", p->data);
  			if (top < MAX - 1)
  			{
  				Node[top] = p;
  				top++;
  				p = p->lchild;
  			}
  		}
  		if (top <= 0)	return;
  		else {
  			top--;
  			q = Node[top];
  			p = q->rchild;
  		}
  	}
  }*/
  void print(Ttree T) {
  	Ttree p;
  	p = T;
  	if (p == NULL)
  		return;
  	printf("%d ", p->data);
  	print(T->lchild);
  	print(T->rchild);
  }
  void safe_flush(FILE* fp) {
  	int ch;
  	while ((ch = fgetc(fp) != EOF && ch != '\n'));
  }
  #endif 
  ```

  **主文件**

```c
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include"tree.h"
int main() {
	Ttree T,p,q,pre,pre1;
	T = (Ttree)malloc(sizeof(TNode));
	int num,flag=0;
	int x, y, j = 0;
	char loc,jud;
	pre = pre1 = T;
	creat(&T);
	p = T;
	printf("请输入你要输入节点的个数:");
	scanf_s("%d",&num);
	printf("输入数据和你想要插的方向:");
		while (scanf("%d,%d,%c", &x, &y,&loc) ==3) {
			insertLdhild(p, x);
			insertRchild(p, y);
			switch (loc) {
			case 'l': pre = p; p = p-> lchild; break;
			case 'r': pre = p; p = p->rchild; break;
			case 'p':p = pre->lchild; break;
			case 't':p = pre->rchild; break;
			}
			printf("输入数据和你想要插的方向:");
		}
	q = T->rchild;
	printf("------------");
	print(T);
}
```

