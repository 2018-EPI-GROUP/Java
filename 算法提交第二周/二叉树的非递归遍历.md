## 二叉树的非递归遍历

#### 中(前)序遍历

```c
void print_1(Ttree T) {
	Ttree p, q;
	Ttree stack[MAX];
	int top;
	if (T == NULL)	return;
	top = 0;
	stack[top] = T;
	p = T;
	/*
	三种情况：1.刚好碰到叶子节点此时p==NULL&&top!=0;
			  2.刚开始的状态p!=NULL&&top==0;
			  3.路程中的状态p!=NULL&&top!=0;
			综上情况：可以将循环的条件弄成!(p==NULL&&top==0).
	*/
	while (!(p == NULL && top == 0)){
		while (p) {
			if (top < MAX - 1) {
                /*若输出语句加到此处，则为前序遍历*/
				top++;
				stack[top] = p;
			}
			else {
				printf("栈溢出!");
				return;
			}
			p = p->left;
		}
		if (top <= 0) return;
		else {
			p = stack[top];
			top--;
			printf("%d   ", p->num);			//此时为中序遍历
			p = p->right;
		}

	}

}
```

