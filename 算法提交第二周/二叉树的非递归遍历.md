## 二叉树的非递归遍历

#### 中(前)序遍历

```c
void print_1(Ttree T) {
	Ttree p, q;
	Ttree stack[MAX];
	int top;
	if (T == NULL)	return;
	top = 0;
	stack[top] = T;
	p = T;
	/*
	三种情况：1.刚好碰到叶子节点此时p==NULL&&top!=0;
			  2.刚开始的状态p!=NULL&&top==0;
			  3.路程中的状态p!=NULL&&top!=0;
			综上情况：可以将循环的条件弄成!(p==NULL&&top==0).
	*/
	while (!(p == NULL && top == 0)){
		while (p) {
			if (top < MAX - 1) {
                /*若输出语句加到此处，则为前序遍历*/
				top++;
				stack[top] = p;
			}
			else {
				printf("栈溢出!");
				return;
			}
			p = p->left;
		}
		if (top <= 0) return;
		else {
			p = stack[top];
			top--;
			printf("%d   ", p->num);			//此时为中序遍历
			p = p->right;
		}

	}

}
```



**后序遍历**

```c
void poster(Ttree T) {
	Ttree p,q;
	stackType stack[MAX];
	int top = -1,sign;
	if (T == NULL) return;
	p = T;
	/*
	三种情况：1.刚好碰到叶子节点(包括只有一个根节点，此时p==NULL&&top!=-1;
			  2.刚开始的状态p!=NULL&&top==0;
			  3.路程中的状态p!=NULL&&top!=0;
			综上情况：可以将循环的条件弄成!(p==NULL&&top==0).
	*/
	while (!(p == NULL && top == -1)) {
		while(p != NULL) {
			top++;			//从top=-1开始入栈
			stack[top].link = p;
			stack[top].flag = 1;
			p = p->left;
		}
		{
			p = stack[top].link;			//节点出栈
			sign = stack[top].flag;			//获取标志
			top--;
			if (sign == 1) {				//如果为第一次出栈
				top++;						
				stack[top].link = p;
				stack[top].flag = 2;
				p = p->right;				//寻找其右孩子
			}
			else {							//如果为第二次出栈
				printf("%d  ", p->num);		//读取第二次出栈的元素‘
				p = NULL;					//并将该节点置空，以返回上一个元素
			}
		}
	}
}
```

