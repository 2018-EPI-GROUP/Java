#include<stdio.h>
#include<stdlib.h>
#include<malloc.h>


struct node{           //定义单链表
	int data;          //数据域
	struct node *next; //指针域
}Node;

struct node *create()   //尾插法建立单链表,将新结点插到链表的尾部
{
	struct node *head,*s,*p;//设置指针
	int x;                  //设数据元素类型为int
	head=(struct node *)malloc(sizeof(Node)); //生成头结点
	head->next=NULL;                          //表置空
	s=head;                                   
	scanf("%d",&x);
	while(x>0)                               //输入值小于零时结束循环
	{
		p=(struct node *)malloc(sizeof(Node));//申请一个头结点
		p->data=x;                           //赋值
		p->next=NULL;                        //置空
		s->next=p;                           //新的结点插到s所指结点的后面
		s=p;                                 //s指向新的结点
		scanf("%d",&x);                      //输入下一个值
	}
	return head;                             //返回创建的链表
}

struct node *merge(struct node *h1,struct node *h2)   //单链表的合并
{
	struct node *p1,*p2,*s;   
	p1=h1->next;     //p1指向h1第一个数据结点
	p2=h2->next;     //p2指向h2第一个数据结点
	s=h1;
	while(p1&&p2)//h1,h2链表都还没结束时
	{
		if(p1->data<p2->data)//p1的数据元素比h2小
		{
			s->next=p1;      //p1插到s所指结点后面
			s=p1;            //s指向新的结点
			p1=p1->next;     //p1后移     
		}
		else//p1的数据元素比h2大
		{
			s->next=p2;
			s=p2;
			p2=p2->next;
		}
	}
	if(p1)//链表h1还没结束，链表h2先结束，将h1的剩余数据元素放到s所指结点后面
		s->next=p1;
	else//链表h2还没结束，链表h1先结束，将h2的剩余数据元素放到s所指结点后面
		s->next=p2;
	return h1;
}

	void reverse(struct node *head)   //单链表的逆置
	{
		struct node *p,*q;
		p=head->next;//p指向第一个数据结点
		head->next=NULL;//将原链表置为空表
		q=p->next;
		while(p)
		{
			p->next=head->next;//当前结点插到头结点后面
			head->next=p;//头结点指向新的结点
			p=q;
			if(q)//判断p后面还有没有结点
			q=q->next;
		}
	}
	void print(struct node *head)  //输出单链表
	{
		struct node *s;
		s=head->next;//s指向第一个数据结点
		while(s)//s不为空时
		{
			printf("%d",s->data);//输出数据结点的数据元素
			if(s->next)//当它有下一个结点时，中间用间隔隔开
			printf(" ");
			s=s->next;//s指针移向新的结点
		}
		printf("\n");//换行
	}
	int main()    //主函数
	{
		struct node *h1,*h2,*h;//定义单链表h1，h2，h
		h1=create();//创建h1
		h2=create();//创建h2
		h=merge(h1,h2);//合并链表
		reverse(h);//链表逆置
		print(h);//输出链表
		return 0;
	}