## 对称二叉树

- **问题描述**

  给定一个二叉树，检查它是否是镜像对称的。

  例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

  ```c
  	1
     / \
    2   2
   / \ / \
  3  4 4  3
  ```

  但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

  ```c
  	1
     / \
    2   2
     \   \
     3    3
  ```

- **数据类型**

```java
public class TreeNode {
     int val;
     TreeNode left;
     TreeNode right;
     TreeNode(int x) { val = x; }
}
```

- **解决方案**

  **一、递归算法**

  - 由于对称树与其第一层的顶点无关，所以其问题转化为判断其左右子树是否相等。

  - 在左右子树中判断每一步的顶点，是否相等，由于是镜面对称，则左子树和右子树从最外向最里判断。

  **代码实现**

  ```java
  
  class Solution {
      public boolean isSymmetric(TreeNode root) {
          if(root==null) return true;
          return ismir(root.left,root.right);
          
      }
      private boolean ismir(TreeNode l,TreeNode r){
         if(l==null&&r==null) return true;	//两个顶点都为空，返回true
         if(l==null||r==null) return false;//只有一个顶点为空，则说明两个顶点不一样，返回false
         if(l.val!=r.val) return false;	//如果两个顶点的值不相等，则说明其不对称返回false
         return ismir(l.left,r.right)&&ismir(l.right,r.left);//最终返回左子树和右子树是否相等
      }
  }
  ```

  **二、迭代算法**

  - 利用类似BFS的广度优先算法，利用队列来存储，每次需要比较的值。
  - 由于对称树与其第一层的顶点无关，所以其问题转化为判断其左右子树是否相等。
  - 在左右子树中分别取出对应顶点进行比较，由外向内，当队列为空时，则说明判断完毕。

  **代码实现**

  ```c
  //定义队列结构类型 
  typedef struct st{
       struct TreeNode* tree[MAX];
       int front;
       int rear;
       int num;
   }per,*Queue;
  //元素入队列
   void add(Queue pep,struct TreeNode *p){
       pep->rear=(pep->rear+1)%MAX;
       pep->tree[pep->rear]=p;
       pep->num++;
   }
  //元素出队列并返回，出来的节点
  struct TreeNode *pop(Queue pep){
      struct TreeNode *q;
      q=pep->tree[pep->front];
      pep->front=(pep->front+1)%MAX;
      pep->num--;
      return pep;
  }
  //广度优先判断对应的节点是否相等
  bool isSymmetric(struct TreeNode* root){
      if(root==NULL) return true;
      Queue q;
      q=(Queue)malloc(sizeof(per));
      if(q==NULL) return false;
      q->front=0;
      q->rear=1;
      q->tree[q->front]=root->left;
      q->tree[q->rear]=root->right;
      q->num=2;
      while(q->num>0)
      {
          struct TreeNode *lchild = pop(q);
          struct TreeNode *rchild = pop(q);
          if(lchild==NULL && rchild==NULL) continue;
          if(lchild==NULL||rchild==NULL) return false;
          if(lchild->val!=rchild->val) return false;
          add(q,lchild->left);
          add(q,rchild->right);
          add(q,lchild->right);
          add(q,rchild->left);
      }
      return true;
  }
  ```

  