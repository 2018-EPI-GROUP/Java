## 归并排序

- **代码描述**

  ```c
  /*二路归并算法*/
  void Merge(int* num, int* p, int u, int v, int t) 
  {
  	int i,j,k;
  	for (i = u, j = v, k = u; i < v &&j <= t; k++) {
  		if (num[i] > num[j]) {
  			p[k] = num[j];
  			j++;
  		}
  		else if (num[i] <= num[j]) {
  			p[k] = num[i];
  			i++;
  		}
  	}
  	while (i < v) {
  		p[k] = num[i];
  		i++;  k++;
  	}
  	while (j <= t) {
  		p[k] = num[j];
  		j++;  k++;
  	}
  }
  /*归并排序*/
  void MergeSort(int* num, int* p,int length)
  {
  	int  i, j;
  	int* p1 = num, * p2 = p, * trans;
  	int len;
  	for (len = 1; len < length; len *= 2) {
  		for (i = 0; i + 2 * len - 1 < length; i += 2 * len)
  			Merge(p1, p2, i, i + len, i + 2 * len - 1);
  		if (i + len < length) 	//如果还有未归并的，且两个子串长度不相等，则连接之
  			Merge(p1, p2, i, i + len, length-1);
  		else if(i < length){		//如果只剩一点点，无法进行匹配，则将剩余的全都传递给新的数组
  			while (i < length) {
  				p2[i] = p1[i];
  				i++;
  			}
  		}	
  		//将p1和p2交换，以进行下一长度的归并
  	    trans = p2;
  		p2 = p1;
  		p1 = trans;
  
  		
  		for (i = 0; i < MAX; i++) {
  			printf("%d ", num[i]);
  		}
  		putchar('\n');
  	}
  	    if (p1 != num) {
  		  for (i = 0; i < length; i++) {
  			num[i] = p1[i];
  		  }
  	    }
  	
  }
  ```

  