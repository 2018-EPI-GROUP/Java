## 二分法查找

- **问题描述**

- 给定一个 `n` 个元素的整型数组 `nums` 和一个目标值 `target`  ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。

  
  **示例 1:**

  ```
  输入: nums = [-1,0,3,5,9,12], target = 9
  输出: 4
  解释: 9 出现在 nums 中并且下标为 4
  ```

  **示例 2:**

  ```
  输入: nums = [-1,0,3,5,9,12], target = 2
  输出: -1
  解释: 2 不存在 nums 中因此返回 -1
  ```

   

  **提示：**

  1. 你可以假设 `nums` 中的所有元素是不重复的。
  2. `n` 将在 `[1, 10000]`之间。
  3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

```java
public static void main(String[] args) {
		final int MAXSIZE = 7;
		int nums[] = new int[MAXSIZE];
		Scanner sc = new Scanner(System.in);
		Map<Integer,Integer> num = new HashMap<>();	//用Map结合存贮每个值和其对应的下标
		int i;
		for(i=1;i<MAXSIZE;i++) {
			nums[i]=sc.nextInt();	//从第一位开始储存，0位置为辅助空位
			num.put(nums[i], i);
		}
		System.out.println("请输入你的target:");
		int target = sc.nextInt();
		Shellsort(nums, MAXSIZE);
		int obj = search(nums,num, target);
		System.out.println(obj);
		
	}
	/*Shell排序*/
	public static void ShellInsert(int nums[], int size) {
		int i, j;
		for (i = 1+size; i <= 6; i++) {
			if (nums[i - size] > nums[i]) {
				nums[0] = nums[i];
				for (j = i - size; j > 0 && nums[j] > nums[0]; j-=size) {
					nums[j + size] = nums[j];
				}
				j += size;
				nums[j] = nums[0];
			}
		}
	}
	public static void Shellsort(int nums[],int numsSize) {
		int i, j;
		final int AID_MAX = 5;
		int aid[] = { 5,4,3,2,1 };
		for (i = 0; i < AID_MAX; i++) {
			ShellInsert(nums, aid[i]);
		}
	}
	/*二分法查找*/
	public static int search(int nums[], Map<Integer,Integer> res, int target) {
		int left = 1, right = nums.length;
		int mid;
		while (left <= right) {
			mid = (left + right) / 2;
			if(0<=mid&&mid<nums.length) {
				if (nums[mid] < target)
					left = mid + 1;
				if (nums[mid] > target)
					right = mid - 1;
				else if(nums[mid]==target)
					return res.get(nums[mid]);
			}else
				return -1;
			
		}
		return -1;
	}
```

